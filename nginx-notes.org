#+TITLE: Notes of Nginx
#+AUTHOR: Liu Xiang
* Controlling Nginx
** PID
   The process ID of the master process is written to the file
   =/usr/local/nginx/logs/nginx.pid= by default. This name may be changed at
   configuration time, or in =nginx.conf= using the [[http://127.0.0.1:55752/Dash/bfctgfpm/nginx.org/en/docs/ngx_core_module.html#pid][pid]] directive
** Signals

   The master process supports the following signals:

   | Signal    | Description                                                                                       |
   |-----------+---------------------------------------------------------------------------------------------------|
   | TERM, INT | fast shutdown                                                                                     |
   | QUIT      | graceful shutdown                                                                                 |
   | HUP       | changing configuration, keeping up with a changed time zone (only for FreeBSD and Linux),         |
   |           | starting new worker processes with a new configuration, graceful shutdown of old worker processes |
   | USR1      | re-opening log files                                                                              |
   | USR2      | upgrading an executable file                                                                      |
   | WINCH     | graceful shutdown of worker processes                                                             |
* Setting up hashes

  + =xxx_hash_max_size=: Total number of buckets the /xxx/ has.
  + =xxx_hash_bucket_size=: Size of one single bucket.
* Debugging Log
** Prerequisite
   To enable a debugging log, nginx needs to be configured to support debugging during the build:

   #+BEGIN_SRC sh
     ./configure --with-debug ...
   #+END_SRC
** Turn debugging log on gloablly

   #+BEGIN_SRC nginx
     error_log /var/lib/logs/nginx/err.log debug;
   #+END_SRC
** Tunr debugging on only for some clients

   #+BEGIN_SRC nginx
     error_log /path/to/log;

     events {
         debug_connection 192.168.1.1;
         debug_connection 192.168.10.0/24;
     }
   #+END_SRC
* Measurement Units
** Size
   + =k= / =K=
   + =m= / =M=
   + =g= / =G=
** Time
   + =ms= milliseconds
   + =s= seconds
   + =m= minutes
   + =h= hours
   + =d= days
   + =w= weeks
   + =M= months (30 days)
   + =y= years (365 days)

* Command-line Parameters

  nginx supports the following command-line parameters:

  - =-?= | =-h= --- print help for command-line parameters.
  - =-c file= --- use an alternative configuration =file= instead of a default file.
  - =-g directives= --- set [[http://127.0.0.1:55752/Dash/bfctgfpm/nginx.org/en/docs/ngx_core_module.html][global configuration directives]], for example,
    #+BEGIN_SRC nginx
      nginx -g "pid /var/run/nginx.pid; worker_processes `sysctl -n hw.ncpu`;"
    #+END_SRC
  - =-p prefix= --- set nginx path prefix, i.e. a directory that will keep
    server files (default value is =/usr/local/nginx=).
  - =-q= --- suppress non-error messages during configuration testing.
  - =-s signal= --- send a /signal/ to the master process. The argument /signal/ can be one of:
    - =stop= --- shut down quickly
    - =quit= --- shut down gracefully
    - =reload= --- reload configuration, start the new worker process with a new
      configuration, gracefully shut down old worker processes.
    - =reopen= --- reopen log files
  - =-t= --- test the configuration file: nginx checks the configuration for
    correct syntax, and then tries to open files referred in the configuration.
  - =-T= --- same as =-t=, but additionally dump configuration files to standard output (1.9.2).
  - =-v= --- print nginx version.
  - =-V= --- print nginx version, compiler version, and configure parameters.
* Default Server
  Nginx first decides which /server/ should process the request. Let's start
  with a simple configuration where all three virtual servers listen on port
  =*:80=:

  #+BEGIN_SRC nginx
    server {
        listen      80;
        server_name example.org www.example.org;
        ...
    }

    server {
        listen      80;
        server_name example.net www.example.net;
        ...
    }

    server {
        listen      80;
        server_name example.com www.example.com;
        ...
    }
  #+END_SRC


  In this configuration nginx tests only the request's header field “Host” to
  determine which server the request should be routed to. If its value does not
  match any server name, or the request does not contain this header field at
  all, then nginx will route the request to the default server for this port. In
  the configuration above, the default server is the first one --- which is
  nginx's standard default behaviour. It can also be set explicitly which server
  should be default, with the =default_server= parameter in the [[http://127.0.0.1:55752/Dash/bfctgfpm/nginx.org/en/docs/http/ngx_http_core_module.html#listen][listen]]
  directive:

  #+BEGIN_SRC nginx
    server {
        listen      80 default_server;
        server_name example.net www.example.net;
        ...
    }
  #+END_SRC

  Note that the default server is a property of the listen port and not of the
  server name.


  If requests without the “Host” header field should not be allowed, a server
  that just drops the requests can be defined:

  #+BEGIN_SRC nginx
    server {
        listen 80;
        server_name "";
        return 444;
    }
  #+END_SRC
* Server Names
** Server name matching precedence

   1. extact name
   2. longest wildcard name starting with an asterisk, e.g. =*.example.org=
   3. longest wildcard name ending with an asterick, e.g. =mail.*=
   4. first matching regular expression
** Wildcard server name limitation

   A wildcard name may contain an asterisk only on the name’s start or end, and
   only on a dot border. The names =www.*.example.org= and =w*.example.org= are
   invalid.
** A special wildcard form

   =.example.org= can be used to match both the exact name =example.org= and the
   wildcard name =*.example.org=.
** Regular Expression Server Names

   It must start with the tilde character:

   #+BEGIN_SRC nginx
     server_name  ~^www\d+\.example\.net$;
   #+END_SRC

   A regular expression containing the characters ={= and =}= should be quoted.
** $hostname

   If a server name is defined as =$hostname= (0.9.4), the machine’s hostname
   is used.
** IDN (Internationalized Domain Name)

   Internationalized domain names (IDNs) should be specified using an ASCII
   (Punycode) representation in the server_name directive:

   #+BEGIN_SRC nginx
     server {
         listen       80;
         server_name  xn--e1afmkfd.xn--80akhbyknj4f;  # пример.испытание
         ...
     }
   #+END_SRC
* Load Balancing
** Load balancing methods
   + =round-robin= --- requests to the application servers are distributed in a
     round-robin fashion,
   + =least-connected= --- next request is assigned to the server with the least
     number of active connections,
   + =ip-hash= --- a hash-function is used to determine what server should be
     selected for the next request (based on the client's IP address).
*** Example

    #+BEGIN_SRC nginx
      upstream myapp1 {
          least_conn;
          server srv1.example.com;
          server srv2.example.com;
          server srv3.example.com;
      }

      upstream myapp1 {
          ip_hash;
          server srv1.example.com;
          server srv2.example.com;
          server srv3.example.com;
      }
    #+END_SRC
** Weighted load balancing

   #+BEGIN_SRC nginx
     upstream myapp1 {
         server srv1.example.com weight=3;
         server srv2.example.com;
         server srv3.example.com;
     }
   #+END_SRC
* HTTPS Configuration Example

  #+BEGIN_SRC nginx
    server {
        listen              443 ssl;
        server_name         www.example.com;
        ssl_certificate     www.example.com.crt;
        ssl_certificate_key www.example.com.key;
        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         HIGH:!aNULL:!MD5;
        ...
    }
  #+END_SRC
* Core Functionality
** daemon

   | Syntax:  | daemon on / off; |
   | Default: | daemon on;       |
   | Context: | main             |

   Determines whether nginx should become a daemon. Mainly used during
   development.
** debug_connection

   Example:

   #+BEGIN_SRC nginx
     events {
         debug_connection 127.0.0.1;
         debug_connection localhost;
         debug_connection 192.0.2.0/24;
         debug_connection ::1;
         debug_connection 2001:0db8::/32;
         debug_connection unix:;
     }
   #+END_SRC
** env

   | Syntax:  | env variable[=value]; |
   | Default: | env TZ;               |
   | Context: | main                  |

   By default, nginx removes all environment variables inherited from its parent
   process except the TZ variable.

   Usage Example:

   #+BEGIN_SRC nginx
     env MALLOC_OPTIONS;
     env PERL5LIB=/data/site/modules;
     env OPENSSL_ALLOW_PROXY_CERTS=1;
   #+END_SRC
** error_log

   | Syntax:  | error_log file [level];                    |
   | Default: | error_log logs/error.log error;            |
   | Context: | main, http, mail, stream, server, location |

   log levels:

   =debug=, =info=, =notice=, =warn=, =error=, =crit=, =alert=, or =emerg=.
** load_module

   Loads a dynamic module, e.g.

   #+BEGIN_SRC nginx
     load_module modules/ngx_mail_module.so;
   #+END_SRC
** user

   | Syntax:  | user user [group];  |
   | Default: | user nobody nobody; |
   | Context: | main                |

   Defines user and group credentials used by worker processes. If group is
   omitted, a group whose name equals that of user is used.
** worker_connections

   Sets the maximum number of simultaneous connections that can be opened by a
   worker process. It should be kept in mind that this number includes all
   connections (e.g. connections with proxied servers, among others), not only
   connections with clients. Another consideration is that the actual number of
   simultaneous connections cannot exceed the current limit on the maximum
   number of open files, which can be changed by [[http://127.0.0.1:55752/Dash/bfctgfpm/nginx.org/en/docs/ngx_core_module.html#worker_rlimit_nofile][worker_rlimit_nofile]].
** working_directory

   Defines the current working directory for a worker process. It is primarily
   used when writing a core-file, in which case a worker process should have
   write permission for the specified directory.
* ngx_http_core_module
** absolute_redirect

   | Syntax:  | absolute_redirect on / off; |
   | Default: | absolute_redirect on;       |
   | Context: | http, server, location      |

   If disabled, redirects issued by nginx will be relative.
** alias

   | Syntax:  | alias path; |
   | Default: | —           |
   | Context: | location    |


   Example:

   #+BEGIN_SRC nginx
     location /images {
         root /data/w3/;
     }

     # equals to =>

     location /images {
         alias /data/w3/images;
     }
   #+END_SRC
** client_body_buffer_size

   | Syntax:  | client_body_buffer_size size;     |
   | Default: | client_body_buffer_size 8k / 16k; |
   | Context: | http, server, location            |

   Sets buffer size for reading client request body. In case the request body is
   larger than the buffer, the whole body or only its part is written to a
   temporary file.
** client_body_temp_path

   | Syntax:  | client_body_temp_path path [level1 [level2 [level3]]]; |
   | Default: | client_body_temp_path client_body_temp;                |
   | Context: | http, server, location                                 |

   Defines a directory for storing temporary files holding client request
   bodies. Up to three-level subdirectory hierarchy can be used under the
   specified directory. For example, in the following configuration

   #+BEGIN_SRC nginx
     client_body_temp_path /spool/nginx/client_temp 1 2;
   #+END_SRC

   a path to a temporary file might look like this:

   #+BEGIN_EXAMPLE
     /spool/nginx/client_temp/7/45/00000123457
   #+END_EXAMPLE
** client_header_buffer_size

   | Syntax:  | client_header_buffer_size size; |
   | Default: | client_header_buffer_size 1k;   |
   | Context: | http, server                    |

   Sets buffer size for reading client request header. For most requests, a
   buffer of 1K bytes is enough. However, if a request includes long cookies, or
   comes from a WAP client, it may not fit into 1K. If a request line or a
   request header field does not fit into this buffer then larger buffers,
   configured by the =large_client_header_buffers= directive, are allocated
** large_client_header_buffers

   | Syntax:  | large_client_header_buffers number size; |
   | Default: | large_client_header_buffers 4 8k;        |
   | Context: | http, server                             |


   Sets the max =number= and =size= of buffers used for reading large client
   request header. A request line cannot exceed the size of one buffer, or the
   414 (Request-URI Too Large) error is returned to the client. A request header
   field cannot exceed the size of one buffer as well, or the 400 (Bad Request)
   error is returned to the client. Buffers are allocated only on demand.
** client_max_body_size

   | Syntax:  | client_max_body_size size; |
   | Default: | client_max_body_size 1m;   |
   | Context: | http, server, location     |

   Sets the max allowed size of the client request body, specified in the
   =Content-Length= request header field. If the size in a request exceeds the
   configured value, the 413 (Request Entity Too Large) error is returned to the
   client. Please be aware that browsers cannot correctly display this error.
   Setting =size= to 0 disables checking of client request body size.
** error_page

   | Syntax:  | ~error_page code ... [=[response]] uri;~ |
   | Default: | —                                        |
   | Context: | http, server, location, if in location   |


   Defined the URI that will be shown for the specified errors. A /uri/ value
   can contain variables.

   Example:

   #+BEGIN_SRC nginx
     error_page 404             /404.html;
     error_page 500 502 503 504 /50x.html;
   #+END_SRC

   This causes an internal redirect to the specified /uri/ with the client
   request method changed to =GET= (for all methods other than =GET= and
   =HEAD=).

   Furthermore, it is possible to change the response code to another using the
   =response= syntax, e.g.

   #+BEGIN_SRC nginx
     error_page 404 =200 /empty.gif;
   #+END_SRC

   If an error response is processed by a proxied server or a
   FastCGI/uwsgi/SCGI/gRPC server, and the server may return different response
   codes (e.g., 200, 302, 401, 404), it is possible to respond with the code it
   returns:

   #+BEGIN_SRC nginx
     error_page 404 = /404.php;
   #+END_SRC

   If there is no need to change URI and method during internal redirection it
   is possible to pass processing into a namee location:

   #+BEGIN_SRC nginx
     location / {
         error_page 404 = @fallback;
     }

     location @fallback {
         proxy_pass http://backend;
     }
   #+END_SRC
** etag

   | Syntax:  | =etag on / off;=       |
   | Default: | =etag on;=             |
   | Context: | http, server, location |


   Enables or disables automatic generation of the =ETag= response header field
   for static resources.
** if_modified_since

   | Syntax:  | if_modified_since off / exact / before; |
   | Default: | if_modified_since exact;                |
   | Context: | http, server, location                  |

** ignore_invalid_headers

   | Syntax:  | =ignore_invalid_headers on / off;= |
   | Default: | =ignore_invalid_headers on;=       |
   | Context: | http, server                       |

   Controls whether header fields with invalid names should be ignored. Valid
   names are composed of English letters, digits, hyphens, and possibly
   underscores.

** internal

   | Syntax:  | internal; |
   | Default: | —         |
   | Context: | location  |

   Specifies that a given location can only be sued for internal requests.

** limit_except

   Limits allowed HTTP methods inside a liocation. The =method= parameter can be
   one of the following:
   + =GET=
   + =HEAD=
   + =POST=
   + =PUT=
   + =DELETE=
   + =MKCOL=
   + =COPY=
   + =MOVE=
   + =OPTIONS=
   + =PROFIND=
   + =PROPATCH=
   + =LOCK=
   + =UNLOCK=
   + =PATCH=

   Allowing the =GET= method makes the =HEAD= method also allowed.

   Example:

   #+BEGIN_SRC nginx
     limit_except GET {
         allow 192.168.1.-/24;
         deny all;
     }
   #+END_SRC

** limit_rate

   | Syntax:  | limit_rate rate;                       |
   | Default: | limit_rate 0;                          |
   | Context: | http, server, location, if in location |


   Limits the rate of response transmission to a client. The =rate= is specified
   in bytes per second. Zero value disables rate limiting.

   Rate limit can also be set in the =$limit_rate= variable, e.g.:

   #+BEGIN_SRC nginx
     server {
         if ($slow) {
             set $limit_rate 4k;
         }
     }
   #+END_SRC

** limit_rate_after

   | Syntax:  | limit_rate_after size;                 |
   | Default: | limit_rate_after 0;                    |
   | Context: | http, server, location, if in location |

   Set the initial amount after which the further transmission of a response to
   a client will be rate limited.

   Example:

   #+BEGIN_SRC nginx
     location /flv/ {
         flv;
         limit_rate_after 500k;
         limit_rate 50k;
     }
   #+END_SRC

** listen

   Example:

   #+BEGIN_SRC nginx
     listen 127.0.0.1:8000;
     listen 127.0.0.1;
     listen 8000;
     listen *:8000;
     listen localhost:8000;

     listen [::]:8000;
     listen [::1];
     listen unix:/var/run/nginx.sock;
   #+END_SRC


   if the direct9ive is not present then either =*:80= is used if nginx runs
   with the superuser privileges, or =*:8000= otherwise.

** location

   | Syntax:  | location [ = / ~ / =~*= / =^~= ] uri { ... } |
   |          | location @name { ... }                       |
   | Default: | —                                            |
   | Context: | server, location                             |


   A location can either be defined by a prefix string, or by a regular
   expression. Regular expressions are specified with the preceding =~*=
   modifier (for case-insensitive matching), or the =~= modifier (for
   case-sensitive matching). To find location matching a given request, nginx
   first checks locations defined using the prefix strings (prefix locations).
   Among them, the location with longest matching prefix is selected and
   remembered. Then regular expression are checked, in the order of their
   appearance in the configuration file. The search of regular expressions
   terminates on the first match, and the corresponding configuration is used.
   If no match with a regular expression is found then the configuration of the
   prefix location remembered earlier is used.

   If the longest matching prefix location has the =^~= modifier then regular
   expressions are not checked.

   Also, using the ~=~ modifier it is possible to defined an exact match of URI
   and location. If an exact match is found, the search terminates.

** satisfy

   | Syntax:  | satisfy all / any;     |
   | Default: | satisfy all;           |
   | Context: | http, server, location |

   Example:

   #+BEGIN_SRC nginx
     location / {
         satisfy any;

         allow 192.168.1.0/32;
         deny all;

         auth_basic "closed site";
         auth_basic_user_file conf/htpasswd;
     }
   #+END_SRC

** try_files

   | Syntax:  | try_files file ... uri;   |
   |          | try_files file ... =code; |
   | Default: | —                         |
   | Context: | server, location          |

** Embedded Variables


   | Variable               | Description                                                                       |
   |------------------------+-----------------------------------------------------------------------------------|
   | =$arg_name=            | argument =name= in the request line                                               |
   | =$args=                | arguments in the request line                                                     |
   | =binary_remote_addr=   | client address in a binary form, values's length is always 4 bytes                |
   |                        | for IPv4 addresses or 16 bytes for IPv6 addresses                                 |
   | =$body_bytes_sent=     | number of bytes sent to a client, not counting the response header;               |
   |                        | this variable is compatible with the =%B= parameter of the =mod_log_config=       |
   |                        | Apache module                                                                     |
   | =$bytes_sent=          | number of bytes sent to a client                                                  |
   | =$connection=          | connection serial number                                                          |
   | =$connection_requests= | current number of requests made through a connection                              |
   | =$content_length=      | ~Content-Length~ request header field                                             |
   | =$content_type=        | ~Content-Type~ request header field                                               |
   | =$cookie_name=         | the =name= cookie                                                                 |
   | =$document_root=       | ~root~ or ~alias~ directive's value for the current request                       |
   | =$document_uri=        | same as =$uri=                                                                    |
   | =$host=                | host name from request line > host name form =Host= header > server name matched  |
   | =$hostname=            | host name                                                                         |
   | =$http_name=           | arbitrary request header field; the last part of a variable name                  |
   |                        | is the field name converted to lower case with dashes replaced by underscores     |
   | =$https=               | ~on~ if connection operates in SSL mode, or an empty string otherwise             |
   | =$is_args=             | ~?~ if a request line has arguments, or an empty string otherwise                 |
   | =$limit_rate=          | setting this variable enables response rate limiting                              |
   | =$msec=                | current time in seconds with the milliseoncds resolution                          |
   | =$nginx_version=       | nginx version                                                                     |
   | =$pid=                 | PID of the worker process                                                         |
   | =$pipe=                | ~p~ if request was pipelined, ~.~ otherwise                                       |
   | =$proxy_protocol_addr= | client address from the PROXY protocol header, or an empty string otherwise       |
   | =$proxy_protocol_port= | client port from the PROXY protocol header, or an empty string otherwise          |
   | =$quert_string=        | same as =$args=                                                                   |
   | =$realpath_root=       | an sbsolute pathname corresponding to the =root= or =alias= directive's value     |
   |                        | for the current request, with all symbolic links resolved to real paths           |
   | =$remote_addr=         | client address                                                                    |
   | =$remote_port=         | client port                                                                       |
   | =$remote_user=         | user name supplied with the Basic authentication                                  |
   | =$request=             | full original request line                                                        |
   | =$request_body=        | request body                                                                      |
   | =$request_body_file=   | name of a temporary file with the request body                                    |
   | =$request_completion=  | ~OK~ if a request has completed, or an empty string otherwise                     |
   | =$request_filename=    | file path for the current request, based on the =root= or =alias= directives,     |
   |                        | and the request URI                                                               |
   | =$request_id=          | unique request identifier generated from 16 random bytes, in hexadecimal          |
   | =$request_length=      | request length (including request line, header, and request body)                 |
   | =$request_method=      | request method, usually =GET= or =POST=                                           |
   | =$request_time=        | request processing time in seconds with a milliseconds resolution;                |
   |                        | time elapsed since the first bytes were read from the clinet                      |
   | =$request_uri=         | full original request URI                                                         |
   | =$scheme=              | request scheme, =http= or =https=                                                 |
   | =$sent_http_name=      | arbitrary response header field; the last part of variable name is the field name |
   |                        | converted to lower case with dashes replaced by underscores                       |
   | =$status=              | response status                                                                   |
   | =$uri=                 | current URI in request                                                            |
* ngx_http_access_module

  | Syntax:  | allow address / CIDR / unix: / all;  |
  | Default: | —                                    |
  | Context: | http, server, location, limit_except |

  | Syntax:  | deny address / CIDR / unix: / all;   |
  | Default: | —                                    |
  | Context: | http, server, location, limit_except |


  Example:

  #+BEGIN_SRC nginx
    location / {
        deny  192.168.1.1;
        allow 192.168.1.0/24;
        allow 10.1.1.0/16;
        allow 2001:0db8::/32;
        deny  all;
    }
  #+END_SRC

  The rules are checked in sequence until the first match is found.
* ngx_http_auth_basic_module

  | Syntax:  | auth_basic string / off;             |
  | Default: | auth_basic off;                      |
  | Context: | http, server, location, limit_except |


  Enables validation of user name and password

  | Syntax:  | auth_basic_user_file file;           |
  | Default: | —                                    |
  | Context: | http, server, location, limit_except |


  Specifies a file that keeps user names and passwords, in the following format:

  #+BEGIN_EXAMPLE
    # comment
    name1:password1
    name2:password2:comment
    name3:password3
  #+END_EXAMPLE

  The following password types are supported:

  + encrypted with the =crypt()= function; can be generated using the =htpasswd=
    utility from the Apache HTTP Server distribution or the =openssl passwd=
    command;
  + hashed with the Apache variant of the MD5-based password algorithm (apr1);
    can be generated with the same tools;
  + specified by the ={scheme}data= syntax (1.0.3+) as described in
    [[https://tools.ietf.org/html/rfc2307#section-5.3][RFC 2307]]; currently implemented schemes include =PLAIN= (an example one,
    should not be used), =SHA= (1.3.13) (plain SHA-1 hashing, should not be
    used) and =SSHA= (salted SHA-1 hashing, used by some software packages,
    notably OpenLDAP and Dovecot).
* ngx_http_auth_request_module

  The ngx_http_auth_request_module module (1.5.4+) implements client
  authorization based on the result of a subrequest. If the subrequest returns a
  2xx response code, the access is allowed. If it returns 401 or 403, the access
  is denied with the corresponding error code. Any other response code returned
  by the subrequest is considered an error.

  For the 401 error, the client also receives the “WWW-Authenticate” header
  from the subrequest response.

  Example Configuration

  #+BEGIN_SRC nginx
    location /private/ {
        auth_request /auth;
        ...
    }

    location = /auth {
        proxy_pass ...
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri;
    }
  #+END_SRC


  | Syntax  | =auth_request uri / off;= |
  | Default | =auth_request off;=       |
  | Context | http, server, location    |

  Enables authorization based on the result of a subrequest and sets the URI to
  which the subrequest will be sent.

  | Syntax  | =auth_request_set $variable value;= |
  | Default | —                                   |
  | Context | http, server, location              |

  Sets the request variable to the given value after the authorization request
  completes. The value may contain variables from the authorization request,
  such as =$upstream_http_*=.
* ngx_http_autoindex_module

  Example Configuration

  #+BEGIN_SRC nginx
    location / {
        autoindex on;
    }
  #+END_SRC
* ngx_http_empty_gif_module

  Example

  #+BEGIN_SRC nginx
    location /_.gif {
        empty_gif;
    }
  #+END_SRC
* ngx_http_flv_module
  
  Example

  #+BEGIN_SRC nginx
    location \.flv$ {
        flv;
    }
  #+END_SRC
* ngx_http_mp4_module

  Example

  #+BEGIN_SRC nginx
    location \.mp4$ {
        mp4;
        mp4_buffer_size 1m;
        mp4_max_buffer_size 10m;
    }
  #+END_SRC
* ngx_http_geo_module

  Example

  #+BEGIN_SRC nginx
    geo $geo {
        default         0;
        127.0.0.1       2;
        192.168.1.0/24  1;
        10.1.0.0/16     1;

        ::1             2;
        2001:0db8::/32  1;
    }
  #+END_SRC

  The following special parameters are also supported:

  + delete :: deletes the specified network (0.7.23).
  + default :: a value set to the variable if the client address does not match
               any of the specified addresses. When addresses are specified in
               CIDR notation, “0.0.0.0/0” and “::/0” can be used instead of
               default. When default is not specified, the default value will be
               an empty string.
  + include :: includes a file with addresses and values. There can be several
               inclusions.
  + proxy :: defines trusted addresses (0.8.7, 0.7.63). When a request comes from
             a trusted address, an address from the “X-Forwarded-For” request
             header field will be used instead. In contrast to the regular
             addresses, trusted addresses are checked sequentially. Trusted IPv6
             addresses are supported starting from versions 1.3.0 and 1.2.1.
  + proxy_recursive :: enables recursive address search (1.3.0, 1.2.1). If
       recursive search is disabled then instead of the original client address
       that matches one of the trusted addresses, the last address sent in
       “X-Forwarded-For” will be used. If recursive search is enabled then
       instead of the original client address that matches one of the trusted
       addresses, the last non-trusted address sent in “X-Forwarded-For” will be
       used.
  + ranges :: indicates that addresses are specified as ranges (0.7.23). This
              parameter should be the first. To speed up loading of a geo base,
              addresses should be put in ascending order.

  Example:

  #+BEGIN_SRC nginx
    geo $country {
        default        ZZ;
        include        conf/geo.conf;
        delete         127.0.0.0/16;
        proxy          192.168.100.0/24;
        proxy          2001:0db8::/32;

        127.0.0.0/24   US;
        127.0.0.1/32   RU;
        10.1.0.0/16    RU;
        192.168.1.0/24 UK;
    }
  #+END_SRC
* ngx_http_geoip_module

  Example:

  #+BEGIN_SRC nginx
    http {
        geoip_country         GeoIP.dat;
        geoip_city            GeoLiteCity.dat;
        geoip_proxy           192.168.100.0/24;
        geoip_proxy           2001:0db8::/32;
        geoip_proxy_recursive on;
    }
  #+END_SRC

  Variables:

  + =$geoip_country_code=
  + =$geoip_country_code3=
  + =$geoip_country_name=
  + =$geoip_city=
* ngx_http_gunzip_module

  The ngx_http_gunzip_module module is a filter that decompresses responses with
  =Content-Encoding: gzip= for clients that do not support =gzip= encoding
  method. The module will be useful when it is desireable to store data
  compressed to save space and reduce I/O costs.

  Example:

  #+BEGIN_SRC nginx
    location /storage/ {
        gunzip on;
        ...
    }
  #+END_SRC
* ngx_http_gzip_module

  Example:

  #+BEGIN_SRC nginx
    gzip            on;
    gzip_min_length 1000;
    gzip_proxied    expired no-cache no-store private auth;
    gzip_types      text/plain application/xml;
  #+END_SRC

  Directives:

  + =gzip on | off;=
  + =gzip_buffers number size;=
  + =gzip_comp_level level;= /level/ value: from 1 to 9.
  + =gzip_disable regex ...;= Disable gzipping for matched =User-Agent=
  + =gzip_min_lenth length;=
* ngx_http_headers_module
** add_header

   | Syntax  | add_header name value [always];        |
   | Default | —                                      |
   | Context | http, server, location, if in location |

   Adds the specified field to a response header provided that the response code
   equals 200, 201 (1.3.10), 204, 206, 301, 302, 303, 304, 307 (1.1.16, 1.0.13), or
   308 (1.13.0).

   If the always parameter is specified (1.7.5), the header field will be added
   regardless of the response code.

** add_trailer

   | Syntax  | add_trailer name value [always];       |
   | Default | —                                      |
   | Context | http, server, location, if in location |

   Adds the specified field to the end of a response provided that the response code equals 200, 201, 206, 301, 302, 303, 307, or 308.

** expires

   | Syntax  | expires [modified] time;               |
   |         | expires epoch / max / off;             |
   | Default | expires off;                           |
   | Context | http, server, location, if in location |

   The tim ein ther =Expires= field is computed as a sum of the current time and
   time specified in the directive. If the modifiied parameter is used then the
   time is computed as a sum of the file's modification time and the time
   specified in the directive.

   In addition, it is possible to specify a time of day using the =@= prefix:

   #+BEGIN_SRC nginx
     expires @15h30m;
   #+END_SRC

   The epoch parameter corresponds to the absolute time =Thu, 01 Jan 1970
   00:00:01 GMT=. The contents of the =Cache-Control= field depends on the sign
   of the specified time:

   + time is negative: =Cache-Control: no-cache=
   + time is positive or zero: =Cache-Control: max-age:t=, where t is a time
     specified in the directive, in seconds.

   The max parameter set =Expires= to the value =Thu, 31 Dec 2037 23:55:55 GMT=,
   and =Cache-Control= to 10 years.

   The off parameter disables adding or modifying the =Expires= and
   =Cache-control= repsonse header fields.
* ngx_http_image_filter_module

  Example:

  #+BEGIN_SRC nginx
    location /img/ {
        proxy_pass   http://backend;
        image_filter resize 150 100;
        image_filter rotate 90;
        error_page   415 = /empty;
    }

    location = /empty {
        empty_gif;
    }
  #+END_SRC
** image_filter

   | Syntax  | image_filter off;                   |
   |         | image_filter test;                  |
   |         | image_filter size;                  |
   |         | image_filter rotate 90 / 180 / 270; |
   |         | image_filter resize width height;   |
   |         | image_filter crop width height;     |
   | Default | image_filter off;                   |
   | Context | location                            |
** Other Directives

   |---------+------------------------------------|
   | Syntax  | image_filter_buffer size;          |
   | Default | image_filter_buffer 1M;            |
   | Context | http, server, location             |
   |---------+------------------------------------|
   | Syntax  | image_filter_interlace on / off;   |
   | Default | image_filter_interlace off;        |
   | Context | http, server, location             |
   |---------+------------------------------------|
   | Syntax  | image_filter_jpeg_quality quality; |
   | Default | image_filter_jpeg_quality 75;      |
   | Context | http, server, location             |
   |---------+------------------------------------|
   | Syntax  | image_filter_sharpen percent;      |
   | Default | image_filter_sharpen 0;            |
   | Context | http, server, location             |
   |---------+------------------------------------|
   | Syntax  | image_filter_transparency on/off;  |
   | Default | image_filter_transparency on;      |
   | Context | http, server, location             |
   |---------+------------------------------------|
   | Syntax  | image_filter_webp_quality quality; |
   | Default | image_filter_webp_quality 80;      |
   | Context | http, server, location             |
   |---------+------------------------------------|
* ngx_http_index_module

  Example

  #+BEGIN_SRC nginx
    location / {
        index index.$geo.html index.html;
    }
  #+END_SRC

  | Syntax  | index file ...;        |
  | Default | index index.html;      |
  | Context | http, server, location |
* ngx_http_js_module
  
  Example:

  #+BEGIN_SRC nginx
    http {
        js_include http.js;

        js_set $foo     foo;
        js_set $summary summary;

        server {
            listen 8000;

            location / {
                add_header X-Foo $foo;
                js_content baz;
            }

            location = /summary {
                return 200 $summary;
            }

            location = /hello {
                js_content hello;
            }
        }
    }
  #+END_SRC
  
  The =http.js= file

  #+BEGIN_SRC js
    function foo(r) {
      r.log("hello from foo() handler");
      return "foo";
    }

    function summary(r) {
      var a, s, h;

      s = "JS summary\n\n";

      s += "Method: " + r.method + "\n";
      s += "HTTP version: " + r.httpVersion + "\n";
      s += "Host: " + r.headersIn.host + "\n";
      s += "Remote Address: " + r.remoteAddress + "\n";
      s += "URI: " + r.uri + "\n";

      s += "Headers:\n";
      for (h in r.headersIn) {
        s += "  header '" + h + "' is '" + r.headersIn[h] + "'\n";
      }

      s += "Args:\n";
      for (a in r.args) {
        s += "  arg '" + a + "' is '" + r.args[a] + "'\n";
      }

      return s;
    }

    function baz(r) {
      r.status = 200;
      r.headersOut.foo = 1234;
      r.headersOut['Content-Type'] = "text/plain; charset=utf-8";
      r.headersOut['Content-Length'] = 15;
      r.sendHeader();
      r.send("nginx");
      r.send("java");
      r.send("script");

      r.finish();
    }

    function hello(r) {
      r.return(200, "Hello world!");
    }
  #+END_SRC
* ngx_http_limit_conn_module

  Exmaple:

  #+BEGIN_SRC nginx
    http {
        limit_conn_zone $binary_remote_addr zone=addr:10m;

        ...

        server {

            ...

            location /download/ {
                limit_conn addr 1;
            }

        }
    }
  #+END_SRC
* ngx_http_limit_req_module

  Example:

  #+BEGIN_SRC nginx
    http {
        limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;

        ...

        server {

            ...

            location /search/ {
                limit_req zone=one burst=5;
            }
        }
    }
  #+END_SRC

  | Syntax  | limit_req zone=name [burst=number] [nodelay]; |
  | Default | —                                             |
  | Context | http, server, location                        |

  Sets the shared memory zone and the maximum burst size of requests. If the
  requests rate exceeds the rate configured for a zone, their processing is
  delayed such that requests are processed at a defined rate. Excessive requests
  are delayed until their number exceeds the maximum burst size in which case
  the request is terminated with an error. By default, the maximum burst size is
  equal to zero. For example, the directives
* ngx_http_log_module
  
  Example:

  #+BEGIN_SRC nginx
    log_format compression '$remote_addr - $remote_user [$time_local] '
    '"$request" $status $bytes_sent '
    '"$http_referer" "$http_user_agent" "$gzip_ratio"';

    access_log /spool/logs/nginx-access.log compression buffer=32k;
  #+END_SRC

  Directives:

  | Syntax          | access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]; |
  | access_log off; |                                                                                    |
  | Default         | access_log logs/access.log combined;                                               |
  | Context         | http, server, location, if in location, limit_except                               |

  | Syntax  | log_format name [escape=default/json/none] string ...; |
  | Default | log_format combined "...";                             |
  | Context | http                                                   |
* ngx_http_map_module

  Example:

  #+BEGIN_SRC nginx
    map $http_host $name {
        hostnames;

        default       0;

        example.com   1;
        ,*.example.com 1;
        example.org   2;
        ,*.example.org 2;
        .example.net  3;
        wap.*         4;
    }

    map $http_user_agent $mobile {
        default       0;
        "~Opera Mini" 1;
    }
  #+END_SRC

  Source values are specified as strings or regular expressions (0.9.6).

  + Strings are matched ignoring the case.
  + A regular expression should either start from the “~” symbol for a
    case-sensitive matching, or from the “~*” symbols (1.0.4) for
    case-insensitive matching. A regular expression can contain named and
    positional captures that can later be used in other directives along with
    the resulting variable.

  + The following special parameters are also supported:

  + =default value= sets the resulting value if the source value matches none of
    the specified variants. When default is not specified, the default resulting
    value will be an empty string. hostnames indicates that source values can be
    hostnames with a prefix or suffix mask: The following two records
    #+BEGIN_SRC nginx
      example.com   1;
      *.example.com 1;
    #+END_SRC
    can be combined:
    #+BEGIN_SRC nginx
      .example.com  1;
    #+END_SRC
    This parameter should be specified before the list of values. 
  + =include file= includes a file with values. There can be several inclusions.
* ngx_http_mirror_module
  
  Example:

  #+BEGIN_SRC nginx
    location / {
        mirror /mirror;
        proxy_pass http://backend;
    }

    location = /mirror {
        internal;
        proxy_pass http://test_backend$request_uri;
    }
  #+END_SRC
* ngx_http_proxy_module
** proxy_pass

   | Syntax  | proxy_pass URL;                        |
   | Default | —                                      |
   | Context | location, if in location, limit_except |

   Sets the protocol and address of a proxied server and an optional URI to
   which a location should be mapped. As a protocol, “http” or “https” can
   be specified. The address can be specified as a domain name or IP address,
   and an optional port:

   : proxy_pass http://localhost:8000/uri/;

   or as a UNIX-domain socket path specified after the word “unix” and enclosed in colons:

   : proxy_pass http://unix:/tmp/backend.socket:/uri/;

   If a domain name resolves to several addresses, all of them will be used in a
   round-robin fashion. In addition, an address can be specified as a server
   group.

   Parameter value can contain variables. In this case, if an address is
   specified as a domain name, the name is searched among the described server
   groups, and, if not found, is determined using a resolver.

   A request URI is passed to the server as follows:

   + If the proxy_pass directive is specified with a URI, then when a request is
     passed to the server, the part of a normalized request URI matching the
     location is replaced by a URI specified in the directive:
     #+BEGIN_SRC nginx
       location /name/ {
           proxy_pass http://127.0.0.1/remote/;
       }
     #+END_SRC
   + If proxy_pass is specified without a URI, the request URI is passed to the
     server in the same form as sent by a client when the original request is
     processed, or the full normalized request URI is passed when processing the
     changed URI:
     #+BEGIN_SRC nginx
       location /some/path/ {
           proxy_pass http://127.0.0.1;
       }
     #+END_SRC
     Before version 1.1.12, if proxy_pass is specified without a URI, the
     original request URI might be passed instead of the changed URI in some
     cases.

   In some cases, the part of a request URI to be replaced cannot be determined:

   + When location is specified using a regular expression, and also inside
     named locations. In these cases, proxy_pass should be specified without a
     URI.
   + When the URI is changed inside a proxied location using the rewrite
     directive, and this same configuration will be used to process a request
     (break):
     #+BEGIN_SRC nginx
       location /name/ {
           rewrite    /name/([^/]+) /users?name=$1 break;
           proxy_pass http://127.0.0.1;
       }
     #+END_SRC
     In this case, the URI specified in the directive is ignored and the full
     changed request URI is passed to the server.
   + When variables are used in proxy_pass:
     #+BEGIN_SRC nginx
       location /name/ {
           proxy_pass http://127.0.0.1$request_uri;
       }
     #+END_SRC
     In this case, if URI is specified in the directive, it is passed to the
     server as is, replacing the original request URI.
** proxy_cookie_domain

   | Syntax  | proxy_cookie_domain off;                |
   |         | proxy_cookie_domain domain replacement; |
   | Default | proxy_cookie_domain off;                |
   | Context | http, server, location                  |

   Sets a text that should be changed in the domain attribute of the
   =Set-Cookie= header fields of a proxied server response. Suppose a proxied
   server returned the =Set-Cookie= header field with the attribute
   =domain=localhost=. The directive

   : proxy_cookie_domain localhost example.org

   will rewrite this attribute to =domain=example.org=.
** proxy_hide_header

   | Syntax  | proxy_hide_header field; |
   | Default | —                        |
   | Context | http, server, location   |

   By default, nginx does not pass the header fields =Date=, =Server=, =X-Pad=,
   and =X-Accel-...= from the response of a proxied server to a client. this
   directive sets additional fields that will not be passes. If, on the
   contrary, the passing of fields need to be permitted, the =proxy_pass_header=
   directive can be used.
** proxy_pass_header

   | Syntax  | proxy_pass_header field; |
   | Default | —                        |
   | Context | http, server, location   |

   Permits passing otherwise disabled header fields from a proxied server to a client.
** proxy_redirect

   | Syntax  | proxy_redirect default;              |
   |         | proxy_redirect off;                  |
   |         | proxy_redirect redirect replacement; |
   | Default | proxy_redirect default;              |
   | Context | http, server, location               |

   Sets the text that should be changed in the “Location” and “Refresh”
   header fields of a proxied server response. Suppose a proxied server returned
   the header field “Location: http://localhost:8000/two/some/uri/”. The
   directive

   : proxy_redirect http://localhost:8000/two/ http://frontend/one/;

   will rewrite this string to “Location: http://frontend/one/some/uri/”.

   A server name may be omitted in the replacement string:

   : proxy_redirect http://localhost:8000/two/ /;

   then the primary server’s name and port, if different from 80, will be
   inserted.

   The default replacement specified by the default parameter uses the
   parameters of the location and proxy_pass directives. Hence, the two
   configurations below are equivalent:

   #+BEGIN_SRC nginx
     location /one/ {
         proxy_pass     http://upstream:port/two/;
         proxy_redirect default;

         location /one/ {
             proxy_pass     http://upstream:port/two/;
             proxy_redirect http://upstream:port/two/ /one/;
         }
     }
   #+END_SRC


   The default parameter is not permitted if proxy_pass is specified using
   variables.

   A replacement string can contain variables:

   : proxy_redirect http://localhost:8000/ http://$host:$server_port/;

   A redirect can also contain (1.1.11) variables:

   : proxy_redirect http://$proxy_host:8000/ /;

   The directive can be specified (1.1.11) using regular expressions. In this
   case, redirect should either start with the “~” symbol for a case-sensitive
   matching, or with the “~*” symbols for case-insensitive matching. The
   regular expression can contain named and positional captures, and replacement
   can reference them:

   #+BEGIN_SRC nginx
     proxy_redirect ~^(http://[^:]+):\d+(/.+)$ $1$2;
     proxy_redirect ~*/user/([^/]+)/(.+)$      http://$1.example.com/$2;
   #+END_SRC

   There could be several proxy_redirect directives:

   #+BEGIN_SRC nginx
     proxy_redirect default;
     proxy_redirect http://localhost:8000/  /;
     proxy_redirect http://www.example.com/ /;
   #+END_SRC

   The off parameter cancels the effect of all proxy_redirect directives on the
   current level:

   #+BEGIN_SRC nginx
     proxy_redirect off;
     proxy_redirect default;
     proxy_redirect http://localhost:8000/  /;
     proxy_redirect http://www.example.com/ /;
   #+END_SRC

   Using this directive, it is also possible to add host names to relative
   redirects issued by a proxied server:

   : proxy_redirect / /;

** proxy_set_header

   | Syntax  | proxy_set_header field value;      |
   | Default | proxy_set_header Host $proxy_host; |
   |         | proxy_set_header Connection close; |
   | Context | http, server, location             |

   Allows redefining or appending fields to the request header passed to the
   proxied server. The value can contain text, variables, and their
   combinations. These directives are inherited from the previous level if and
   only if there are no proxy_set_header directives defined on the current
   level. By default, only two fields are redefined:

   #+BEGIN_SRC nginx
     proxy_set_header Host       $proxy_host;
     proxy_set_header Connection close;
   #+END_SRC

   If caching is enabled, the header fields “If-Modified-Since”,
   “If-Unmodified-Since”, “If-None-Match”, “If-Match”, “Range”, and
   “If-Range” from the original request are not passed to the proxied server.

   An unchanged “Host” request header field can be passed like this:

   : proxy_set_header Host       $http_host;

   However, if this field is not present in a client request header then nothing
   will be passed. In such a case it is better to use the $host variable - its
   value equals the server name in the “Host” request header field or the
   primary server name if this field is not present:

   : proxy_set_header Host       $host;

   In addition, the server name can be passed together with the port of the
   proxied server:

   : proxy_set_header Host       $host:$proxy_port;

   If the value of a header field is an empty string then this field will not be
   passed to a proxied server:

   : proxy_set_header Accept-Encoding "";

* ngx_http_referer_module

  Example:

  #+BEGIN_SRC nginx
    valid_referers none blocked server_names
            ,*.example.com example.* www.example.org/galleries/
            ~\.google\.;

    if ($invalid_referer) {
        return 403;
    }
  #+END_SRC

  | Syntax  | valid_referers none / blocked / server_names / string ...; |
  | Default | —                                                          |
  | Context | server, location                                           |

  Specifies the “Referer” request header field values that will cause the embedded $invalid_referer variable to be set to an empty
  string. Otherwise, the variable will be set to “1”. Search for a match is case-insensitive.

  Parameters can be as follows:

  + none :: the “Referer” field is missing in the request header;
  + blocked :: the “Referer” field is present in the request header, but its
               value has been deleted by a firewall or proxy server; such values
               are strings that do not start with “http://” or “https://”;
  + server_names :: the “Referer” request header field contains one of the
                    server names;
  + arbitrary string :: defines a server name and an optional URI prefix. A server
       name can have an “*” at the beginning or end. During the checking, the
       server’s port in the “Referer” field is ignored;
  + regular expression :: the first symbol should be a “~”. It should be noted
       that an expression will be matched against the text starting after the
       “http://” or “https://”.
* ngx_http_rewrite_module

  The ngx_http_rewrite_module module is used to change request URI using PCRE
  regular expressions, return redirects, and conditionally select
  configurations.

  The break, if, return, rewrite, and set directives are processed in the
  following order:

  + the directives of this module specified on the server level are executed sequentially;
  + repeatedly:
    + a location is searched based on a request URI;
    + the directives of this module specified inside the found location are executed sequentially;
    + the loop is repeated if a request URI was rewritten, but not more than 10 times.

  | Syntax  | rewrite regex replacement [flag]; |
  | Default | —                                 |
  | Context | server, location, if              |

  If the specified regular expression matches a request URI, URI is changed as
  specified in the replacement string. The rewrite directives are executed
  sequentially in order of their appearance in the configuration file. It is
  possible to terminate further processing of the directives using flags. If a
  replacement string starts with “http://”, “https://”, or “$scheme”, the
  processing stops and the redirect is returned to a client.

  An optional flag parameter can be one of:

  + last :: stops processing the current set of ngx_http_rewrite_module
            directives and starts a search for a new location matching the
            changed URI;
  + break :: stops processing the current set of ngx_http_rewrite_module
             directives as with the break directive;
  + redirect :: returns a temporary redirect with the 302 code; used if a
                replacement string does not start with “http://”,
                “https://”, or “$scheme”;
  + permanent :: returns a permanent redirect with the 301 code.
* ngx_http_split_clients_module

  Example:

  #+BEGIN_SRC nginx
    http {
        split_clients "${remote_addr}AAA" $variant {
            0.5%               .one;
            2.0%               .two;
            ,*                  "";
        }

        server {
            location / {
                index index${variant}.html;
            }
        }
    }
  #+END_SRC

  | Syntax  | split_clients string $variable { ... } |
  | Default | —                                      |
  | Context | http                                   |

  Creates a variable for A/B testing, for example:

  #+BEGIN_SRC nginx
    split_clients "${remote_addr}AAA" $variant {
        0.5%               .one;
        2.0%               .two;
        ,*                  "";
    }
  #+END_SRC

  The value of the original string is hashed using MurmurHash2. In the example
  given, hash values from 0 to 21474835 (0.5%) correspond to the value ".one" of
  the $variant variable, hash values from 21474836 to 107374180 (2%) correspond
  to the value ".two", and hash values from 107374181 to 4294967295 correspond
  to the value "" (an empty string).
* ngx_http_sub_module
  
  Example:

  #+BEGIN_SRC nginx
    location / {
        sub_filter '<a href="http://127.0.0.1:8080/'  '<a href="https://$host/';
        sub_filter '<img src="http://127.0.0.1:8080/' '<img src="https://$host/';
        sub_filter_once on;
        sub_filter_types text/plain;
    }
  #+END_SRC
* ngx_http_upstream_module

  Examples:

  #+BEGIN_SRC nginx
    upstream backend {
        server backend1.example.com       weight=5;
        server backend2.example.com:8080;
        server unix:/tmp/backend3;

        server backup1.example.com:8080   backup;
        server backup2.example.com:8080   backup;
    }

    server {
        location / {
            proxy_pass http://backend;
        }
    }

    upstream dynamic {
        zone upstream_dynamic 64k;

        server backend1.example.com      weight=5;
        server backend2.example.com:8080 fail_timeout=5s slow_start=30s;
        server 192.0.2.1                 max_fails=3;
        server backend3.example.com      resolve;
        server backend4.example.com      service=http resolve;

        server backup1.example.com:8080  backup;
        server backup2.example.com:8080  backup;
    }

    server {
        location / {
            proxy_pass http://dynamic;
            health_check;
        }
    }
  #+END_SRC
** upstream

   | Syntax  | upstream name { ... } |
   | Default | —                     |
   | Context | http                  |

   Defines a group of servers. Servers can listen on different ports. In
   addition, servers listening on TCP and UNIX-domain sockets can be mixed.

   Example:

   #+BEGIN_SRC nginx
     upstream backend {
         server backend1.example.com weight=5;
         server 127.0.0.1:8080       max_fails=3 fail_timeout=30s;
         server unix:/tmp/backend3;

         server backup1.example.com  backup;
     }
   #+END_SRC

   By default, requests are distributed between the servers using a weighted
   round-robin balancing method. In the above example, each 7 requests will be
   distributed as follows: 5 requests go to backend1.example.com and one request
   to each of the second and third servers. If an error occurs during
   communication with a server, the request will be passed to the next server,
   and so on until all of the functioning servers will be tried. If a successful
   response could not be obtained from any of the servers, the client will
   receive the result of the communication with the last server.
** server

   | Syntax  | server address [parameters]; |
   | Default | —                            |
   | Context | upstream                     |

   Defines the address and other parameters of a server. The address can be
   specified as a domain name or IP address, with an optional port, or as a
   UNIX-domain socket path specified after the “unix:” prefix. If a port is not
   specified, the port 80 is used. A domain name that resolves to several IP
   addresses defines multiple servers at once.

   The following parameters can be defined:

   + =weight=number= :: sets the weight of the server, by default, 1.
   + =max_conns=number= :: limits the maximum number of simultaneous active
        connections to the proxied server (1.11.5). Default value is zero, meaning
        there is no limit. If the server group does not reside in the shared
        memory, the limitation works per each worker process.
        + If idle keepalive connections, multiple workers, and the shared memory are
          enabled, the total number of active and idle connections to the proxied
          server may exceed the max_conns value.
        + Since version 1.5.9 and prior to version 1.11.5, this parameter was
          available as part of our commercial subscription.
   + =max_fails=number= :: sets the number of unsuccessful attempts to communicate
        with the server that should happen in the duration set by the fail_timeout
        parameter to consider the server unavailable for a duration also set by the
        fail_timeout parameter. By default, the number of unsuccessful attempts is
        set to 1. The zero value disables the accounting of attempts. What is
        considered an unsuccessful attempt is defined by the proxy_next_upstream,
        fastcgi_next_upstream, uwsgi_next_upstream, scgi_next_upstream,
        memcached_next_upstream, and grpc_next_upstream directives.
   + =fail_timeout=time= :: sets
        + the time during which the specified number of unsuccessful attempts to
          communicate with the server should happen to consider the server
          unavailable;
        + and the period of time the server will be considered unavailable. \\
        By default, the parameter is set to 10 seconds.
   + =backup= :: marks the server as a backup server. It will be passed requests
                 when the primary servers are unavailable.
   + =down= :: marks the server as permanently unavailable.

** hash

   | Syntax  | hash key [consistent]; |
   | Default | —                      |
   | Context | upstream               |

   This directive appeared in version 1.7.2.

   Specifies a load balancing method for a server group where the client-server
   mapping is based on the hashed key value. The key can contain text,
   variables, and their combinations. Note that adding or removing a server from
   the group may result in remapping most of the keys to different servers. The
   method is compatible with the Cache::Memcached Perl library.

   If the consistent parameter is specified the ketama consistent hashing method
   will be used instead. The method ensures that only a few keys will be
   remapped to different servers when a server is added to or removed from the
   group. This helps to achieve a higher cache hit ratio for caching servers.
   The method is compatible with the Cache::Memcached::Fast Perl library with
   the ketama_points parameter set to 160.
   
** ip_hash

   Specifies that a group should use a load balancing method where requests are
   distributed between servers based on client IP addresses. The first three
   octets of the client IPv4 address, or the entire IPv6 address, are used as a
   hashing key. The method ensures that requests from the same client will
   always be passed to the same server except when this server is unavailable.
   In the latter case client requests will be passed to another server. Most
   probably, it will always be the same server as well.

   IPv6 addresses are supported starting from versions 1.3.2 and 1.2.2.

   If one of the servers needs to be temporarily removed, it should be marked
   with the down parameter in order to preserve the current hashing of client IP
   addresses.
   
** least_conn

   Specifies that a group should use a load balancing method where a request is
   passed to the server with the least number of active connections, taking into
   account weights of servers. If there are several such servers, they are tried
   in turn using a weighted round-robin balancing method.
